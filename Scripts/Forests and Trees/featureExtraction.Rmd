---
title: "featureExtraction"
author: "Ian Douglas"
date: "3/22/2020"
output: html_document
---
### Read in the results from the AUC VIM procedure
```{r}
# RF models built with ranger(), employing stratified sampling, & using balanced training data
stratified_rangers_100 = readRDS("../../output/RF/testSetAUC_VIM_featureSelection_stratified_100.rds")
# "stratified rangers" contains three such models, each using a different randomization seed
model_data = readRDS("../../data/processed/labelledFCor.rds") %>% select(-age) %>%
  mutate_if(~(is.character(.) & !is.factor(.)), ~factor(., levels = c("PI","COMP")))
```
# Score the forests wrt. test set AUC
```{r}
allAUCs_strat_100 = lapply(stratified_rangers_100, function(x) {
  map_dbl(x$forest, function(xx) {
    xx$auc
  })
})
crossValScores_strat_100 = as.data.frame(lapply(allAUCs_strat_100, mean))
```

# Plot
```{r}
plt_dat_strat_100 = gather(as.data.frame(allAUCs_strat_100), 
                           key = 'Repetition', value = 'AUC') %>%
  rowwise() %>%
  mutate(forest_AUC = crossValScores_strat_100[[Repetition]]) %>%
  ungroup()

# ggplot(plt_dat_strat) +
#   geom_density(aes(color = Repetition, x = AUC, fill = Repetition), alpha=.01)

densityplot_100 <- ggplot(plt_dat_strat_100) +
  geom_density(aes(group = Repetition, x = AUC), color = NA, 
               show.legend = F, fill = "black", alpha=.025) +
  geom_density(aes(group = 1, x = AUC), alpha = .01, color = 'white', size = 1.25)
  
densityplot_100 + 
  theme_linedraw() +
  theme(
    panel.grid = element_line(colour = 'black', size = 1),
    panel.border = element_rect(size = 1.25)
  )
```
```{r, echo=FALSE, eval=FALSE}
plt_dat_strat_100 %>%
  mutate(chance = ifelse(forest_AUC > .5, "above", "below"),
         seed = 1 + min_max(as.numeric(sub("^.+_","",Repetition)))*.5) %>%
ggplot(.) +
  geom_density(aes(group = Repetition, x = AUC,color = chance, weight = seed), fill='black',
               alpha=.025, show.legend = F) +
  geom_density(aes(group = 1, x = AUC), alpha = .01, color = 'white', size = 1.25) +
  scale_color_manual(values = c("cyan", "magenta")) +
  theme_linedraw() +
  theme(
    panel.grid = element_line(colour = 'black', size = 1),
    panel.border = element_rect(size = 1.25)
  )
```


# Looking at top vars
```{r}
# Helper function:
min_max = function(data, repel.zero = FALSE) {
  out <- (data - min(data)) / (max(data) - min(data))
  if (repel.zero) {
    second.lowest <- min(replace(out, out == 0, NA), na.rm = T)
    out <- replace(out, out == 0, seq(0, second.lowest, length.out = 3)[2])
  }
  return(out)
}
# Extract the variable importances from each forest
map(paste0("seed_",1:100), 
    ~ stratified_rangers_100[[.]]$importances %>%
      column_to_rownames(var="tree") %>% 
      t %>% 
      as.data.frame %>%
      data.frame(stringsAsFactors = F,
                 'variable'= names(model_data[1:nrow(.)]), 'import'=rowMeans(.)) %>%
      select(variable, import) %>%
      arrange(desc(import))) -> importance_dfs_100
# add the indicator of which random seed was used:
names(importance_dfs_100) <- paste0("seed_",1:100)
for (i in 1:length(importance_dfs_100)) {importance_dfs_100[[i]]$seed = names(importance_dfs_100)[i]}

# Then merge the dataframes to investigate the consistency across seeds; save in wide format
merger = lapply(importance_dfs_100, function(x) select(x, variable, import))
for (i in 1:length(merger)) {names(merger[[i]]) <- c('variable', paste0("import_",i))}
wide_imps_100 = merger %>% purrr::reduce(full_join, by = 'variable')

# Also extract the top 5% of variables for later use; save in long format
Reduce("rbind", importance_dfs_100) %>%
  arrange(seed, desc(import)) -> long_imps_100
# In long format, keep the top 5% of variables (from any tree)
bestVarImpFrame_100 = long_imps_100 %>%
  group_by(seed) %>%
  mutate(seedwise_rank = 1:length(import)) %>%
  filter(seedwise_rank <= round(.05*max(seedwise_rank))) %>% ungroup()
# Globally, these are the top variables:
bestVars_any_100 = unique(bestVarImpFrame_100$variable) # 2071 variables remain

# Best variables, in wide format
bestVars_wide_100 = wide_imps_100 %>%
  filter(variable %in% bestVars_any_100) %>%
  arrange(variable) %>%
  mutate(aggregate_imp = as.double(rowMeans(select(., starts_with("import"))))) %>%
  arrange(desc(aggregate_imp)) %>%
  # scale for plotting aesthetics / interpretability
  mutate(scaled_agg_imp = min_max(aggregate_imp, repel.zero = T))

# Did any variables appear in the top 5% of variables in all three seed iterations? 
if (!any(table(bestVarImpFrame_100$variable) == 100)) {
  print("No variables were found in the top 5% of all forests")
}

# Save a summary that contains the best variable name, and its aggregate importance, as well as its
# average seed-specific ranking aggregated over all seeds
# Rank the variables function (descending)
descending_rank = function(data) { # maximum is ranked #1 (minimum rank) and so forth
  reverseScaled = 1 - min_max(data)
  data.table::frank(reverseScaled)
}
impSummaryBestVars_100 = wide_imps_100 %>%
  filter(variable %in% bestVars_any_100) %>%
  arrange(variable) %>%
  mutate_at(vars(-variable), ~descending_rank(.)) %>%
  mutate(averageRank = rowMeans(select(., -variable))) %>%
  select(variable, averageRank) %>%
  arrange(averageRank) %>%
  left_join(., select(bestVars_wide_100, -starts_with("import")), by = "variable") %>%
  arrange(desc(aggregate_imp)) %>%
  mutate(rank.by.aggImp = 1:nrow(.))
saveRDS(impSummaryBestVars_100, "../../output/bestVarsRanked_allSeedsEqualWeight_100.rds")
```

## Create the adjusted importance
When aggregating across the rows of the $p$ x $num.seed$ variable importance matrix to compute a variable-specific mean importance, "min-max" weight each seed-specific forest's column of variable importances as follows:
1. The forest generating the highest test-set AUC will be weighted at 1
2. The forest with the lowest test-set AUC will adopt a weight of 0
3. All forests with test set AUCs in between will be weighted proportionately to their relative deviation from the lowest and highest AUC
```{r}
weights_100 = min_max(unlist(crossValScores_strat_100))
# insert these weights into a matrix that will scale each data column by its corresponding weight
W <- matrix(0, ncol = 100, nrow = 100)
diag(W) <- weights_100

adjustedVarImp_100 = wide_imps_100 %>%
  column_to_rownames(var='variable') %>%
  as.matrix(.) %*% W %>% # the i-th column is no scaled by the i-th weight, and so on
  data.frame(variable = rownames(.), .) %>%
  mutate(adjusted_CrossVal_Imp = as.double(rowMeans(select(., -variable)))) %>%
  arrange(desc(adjusted_CrossVal_Imp)) %>%
  mutate(rank = 1:nrow(.)) %>%
  # the importance measure is no longer interpretable in terms of AUC improvement, so scale it
  mutate(scaled_adjCrossValImp = scale(adjusted_CrossVal_Imp, center = F))
# fix the names that were lost during matrix multiplication
names(adjustedVarImp_100)[2:101] <- paste0("adjustedImp_", 1:100)
# Proceed as above to obtain the long and wide formats, as well as the top weighted features
bestAdjustedImpFrame_100 = adjustedVarImp_100 %>%
  filter(rank <= round(.05*n_distinct(variable))) %>%
  select(-starts_with("adjustedImp_"))

# Save the result to reference for modeling with
saveRDS(bestAdjustedImpFrame_100,"../../output/RF/bestVars_100Forest_minimizeTestAUC_Weighted_scaled.rds")
# Save all feature importances
saveRDS(adjustedVarImp_100 %>% select(-starts_with("adjustedImp_")),
        "../../ALL_adjustedVarImp_fromRF100.rds")
# best variables in terms of adjusted variable importance
upr_5_ptile = adjustedVarImp_100 %>%
  filter(adjusted_CrossVal_Imp > quantile(adjusted_CrossVal_Imp, probs = .95)) %>%
  select(-starts_with("adjustedImp_"))
saveRDS(upr_5_ptile, "../../bestVar_upr5ptile_adjustedVarImp_RF100.rds")
```

# Plot the best variables
```{r}
#upr_5_ptile <- readRDS("../../bestVar_upr5ptile_adjustedVarImp_RF100.rds")
plt_data = upr_5_ptile$variable[upr_5_ptile$rank <= 30]
impSummaryBestVars_100 %>% arrange(desc(scaled_agg_imp)) %>%
  # just take the top 30 for plotting:
  filter(variable %in% upr_5_ptile$variable[upr_5_ptile$rank <= 30]) %>%
  mutate_at(vars(variable), ~factor(., levels = rev(.))) %>%
ggplot(.) +
  geom_col(aes(variable, y = aggregate_imp, fill = averageRank)) +
  coord_flip() +
  theme_linedraw()
```

### Read in the results from the AUC VIM procedure
```{r}
# RF models built with ranger(), employing stratified sampling, & using balanced training data
stratified_rangers = readRDS("../../output/RF/testSetAUC_VIM_featureSelection_stratified.rds")
# "stratified rangers" contains three such models, each using a different randomization seed
model_data = readRDS("../../data/processed/labelledFCor.rds") %>% select(-age) %>%
  mutate_if(~(is.character(.) & !is.factor(.)), ~factor(., levels = c("PI","COMP")))
```
# Score the forests wrt. test set AUC
```{r}
allAUCs_strat = lapply(stratified_rangers, function(x) {
  map_dbl(x$forest, function(xx) {
    xx$auc
  })
})
crossValScores_strat = as.data.frame(lapply(allAUCs_strat, mean))
```

# Plot
```{r}
plt_dat_strat = gather(as.data.frame(allAUCs_strat), key = 'Repetition', value = 'AUC') %>%
  mutate(forest_AUC = case_when(
    Repetition == 'seed_1' ~ crossValScores_strat$seed_1,
    Repetition == 'seed_2' ~ crossValScores_strat$seed_2,
    Repetition == 'seed_3' ~ crossValScores_strat$seed_3
  ))

ggplot(plt_dat_strat) +
  geom_density(aes(color = Repetition, x = AUC, fill = Repetition), alpha=.01)

ggplot(plt_dat_strat) +
  geom_density(aes(group = Repetition, x = AUC), fill = "red", alpha=.33)
```
# Looking at top vars
```{r}
# Extract the variable importances from each forest
map(c("seed_1","seed_2","seed_3"), 
    ~ stratified_rangers[[.]]$importances %>%
      column_to_rownames(var="tree") %>% 
      t %>% 
      as.data.frame %>%
      data.frame(stringsAsFactors = F,
                 'variable'= names(model_data[1:nrow(.)]), 'import'=rowMeans(.)) %>%
      select(variable, import) %>%
      arrange(desc(import))) -> importance_dfs
# add the indicator of which random seed was used:
names(importance_dfs) <- c("seed_1","seed_2","seed_3")
for (i in 1:3) {importance_dfs[[i]]$seed = names(importance_dfs)[i]}

# Then merge the dataframes to investigate the consistency across seeds; save in wide format
wide_imps = merge(
  select(importance_dfs$seed_1, variable, import_1 = import),
  select(importance_dfs$seed_2, variable, import_2 = import),
  by = "variable"
) %>%
  merge(
    .,
    select(importance_dfs$seed_3, variable, import_3 = import),
    by = "variable"
  )
# Also extract the top 5% of variables for later use; save in long format
Reduce("rbind", importance_dfs) %>%
  arrange(seed, desc(import)) -> long_imps
# In long format, keep the top 5% of variables (from any tree)
bestVarImpFrame = long_imps %>%
  group_by(seed) %>%
  mutate(seedwise_rank = 1:length(import)) %>%
  filter(seedwise_rank <= round(.05*max(seedwise_rank))) %>% ungroup()
# Globally, these are the top variables:
bestVars_any = unique(bestVarImpFrame$variable)

# Best variables, in wide format
bestVars_wide = wide_imps %>%
  filter(variable %in% bestVars_any) %>%
  arrange(variable) %>%
  rowwise() %>%
  mutate(aggregate_imp = mean(c(import_1, import_2, import_3))) %>%
  arrange(desc(aggregate_imp)) %>%
  ungroup() %>%
  mutate(scaled_agg_imp = min_max(aggregate_imp), repel.zero = T)

# Did any variables appear in the top 5% of variables in all three seed iterations? 
if (!any(table(bestVarImpFrame$variable) == 3)) {
  print("No variables were found in the top 5% of all three forests")
}
```

## Create the adjusted importance
When aggregating across the rows of the $p$ x $num.seed$ variable importance matrix to compute a variable-specific mean importance, "min-max" weight each seed-specific forest's column of variable importances as follows:
1. The forest generating the highest test-set AUC will be weighted at 1
2. The forest with the lowest test-set AUC will adopt a weight of 0
3. All forests with test set AUCs in between will be weighted proportionately to their relative deviation from the lowest and highest AUC
```{r}
weights = min_max(unlist(crossValScores_strat))
adjustedVarImp = wide_imps %>%
  mutate(import_1 = as.numeric(import_1 * weights[,1]),
         import_2 = as.numeric(import_2 * weights[,2]),
         import_3 = as.numeric(import_3 * weights[,3])) %>%
  rowwise() %>%
  mutate(adjusted_CrossVal_Imp = mean(c(import_1, import_2, import_3))) %>%
  ungroup() %>%
  arrange(desc(adjusted_CrossVal_Imp)) %>%
  mutate(rank = 1:nrow(.)) %>%
  # the importance measure is no longer interpretable in terms of AUC improvement, so scale it
  mutate_at(vars(adjusted_CrossVal_Imp), ~scale(., center = F))

# Proceed as above to obtain the long and wide formats, as well as the top weighted features
bestAdjustedImpFrame = adjustedVarImp %>%
  filter(rank <= round(.05*n_distinct(variable))) %>%
  select(-starts_with("import_"))

# Save the result to reference for modeling with
saveRDS(bestAdjustedImpFrame,"../../output/RF/bestVars_minimizingTestAUC_Weighted_scaled.rds")
```

```{r, echo=FALSE, eval=FALSE}
stratified_rangers$seed_1$forest[[1]]$true
tree1_test = setNames(data.frame(stratified_rangers$seed_1$forest[[1]]$proba,
                                 stratified_rangers$seed_1$forest[[1]]$truetest),
                      c("PI","COMP","trueClass"))
View(tree1_test)
stratified_rangers$seed_1$forest[[1]]$auc
```


```{r, echo = FALSE}
#rangers = readRDS("../../output/RF/testSetAUC_VIM_featureSelection.rds")
```

```{r, echo=FALSE, eval=FALSE}
### example of ranger sample.fraction argument

library(ranger)
data("iris")
rf_iris <- ranger(Species ~ ., data=iris, replace = TRUE, keep.inbag = TRUE,
                  sample.fraction = c(0.01, 0.1, 0.5))
inbag <- do.call(cbind, rf_iris$inbag.counts)

colSums(inbag[iris$Species == "setosa", ]) # floor(0.01*150) = 1
colSums(inbag[iris$Species == "versicolor", ]) # floor(0.1*150) = 15
colSums(inbag[iris$Species == "virginica", ]) # floor(0.5*150) = 75


# so... n_inbag = floor(pi_sampl_frac * N)
```


